package flux

import (
	"testing"
	"time"
)

// Alignment tests verify our Go implementation produces identical results
// to py-fsrs. Expected values are from testdata/py_fsrs_alignment.json,
// generated by scripts/gen_alignment_data.py.

var t0align = time.Date(2025, 6, 15, 10, 0, 0, 0, time.UTC)

func alignScheduler(t *testing.T) *Scheduler {
	t.Helper()
	s, err := NewScheduler(SchedulerConfig{DisableFuzzing: true})
	if err != nil {
		t.Fatalf("NewScheduler: %v", err)
	}
	return s
}

func assertState(t *testing.T, label string, got, want State) {
	t.Helper()
	if got != want {
		t.Errorf("%s: State = %v, want %v", label, got, want)
	}
}

func assertStep(t *testing.T, label string, got *int, want *int) {
	t.Helper()
	if want == nil {
		if got != nil {
			t.Errorf("%s: Step = %d, want nil", label, *got)
		}
		return
	}
	if got == nil {
		t.Errorf("%s: Step = nil, want %d", label, *want)
		return
	}
	if *got != *want {
		t.Errorf("%s: Step = %d, want %d", label, *got, *want)
	}
}

func assertDue(t *testing.T, label string, got, want time.Time) {
	t.Helper()
	if !got.Equal(want) {
		t.Errorf("%s: Due = %v, want %v", label, got, want)
	}
}

// Scenario 1: NewCard → Good → 10m → Good → 3d → Good
func TestAlignScenario1_GoodGoodGood(t *testing.T) {
	s := alignScheduler(t)
	card := NewCard(1)

	// Step 1: Good at t0
	c, _ := s.ReviewCard(card, Good, t0align)
	assertState(t, "s1.1", c.State, Learning)
	assertStep(t, "s1.1", c.Step, ptrI(1))
	assertFloat(t, "s1.1 S", *c.Stability, 2.3065)
	assertFloat(t, "s1.1 D", *c.Difficulty, 2.118104)
	assertDue(t, "s1.1", c.Due, t0align.Add(10*time.Minute))

	// Step 2: Good at t0+10m
	t1 := t0align.Add(10 * time.Minute)
	c, _ = s.ReviewCard(c, Good, t1)
	assertState(t, "s1.2", c.State, Review)
	assertStep(t, "s1.2", c.Step, nil)
	assertFloat(t, "s1.2 S", *c.Stability, 2.3065)
	assertFloat(t, "s1.2 D", *c.Difficulty, 2.111214)
	assertDue(t, "s1.2", c.Due, t1.Add(2*24*time.Hour))

	// Step 3: Good at t0+3d+10m
	t2 := t0align.Add(3*24*time.Hour + 10*time.Minute)
	c, _ = s.ReviewCard(c, Good, t2)
	assertState(t, "s1.3", c.State, Review)
	assertStep(t, "s1.3", c.Step, nil)
	assertFloat(t, "s1.3 S", *c.Stability, 13.83584)
	assertFloat(t, "s1.3 D", *c.Difficulty, 2.104331)
	assertDue(t, "s1.3", c.Due, t2.Add(14*24*time.Hour))
}

// Scenario 2: NewCard → Again → same-day Good → same-day Good
func TestAlignScenario2_AgainGoodGoodSameDay(t *testing.T) {
	s := alignScheduler(t)
	card := NewCard(1)

	// Step 1: Again at t0
	c, _ := s.ReviewCard(card, Again, t0align)
	assertState(t, "s2.1", c.State, Learning)
	assertStep(t, "s2.1", c.Step, ptrI(0))
	assertFloat(t, "s2.1 S", *c.Stability, 0.212)
	assertFloat(t, "s2.1 D", *c.Difficulty, 6.4133)
	assertDue(t, "s2.1", c.Due, t0align.Add(1*time.Minute))

	// Step 2: Good at t0+5m (same-day → shortTermStability)
	t1 := t0align.Add(5 * time.Minute)
	c, _ = s.ReviewCard(c, Good, t1)
	assertState(t, "s2.2", c.State, Learning)
	assertStep(t, "s2.2", c.Step, ptrI(1))
	assertFloat(t, "s2.2 S", *c.Stability, 0.246689)
	assertFloat(t, "s2.2 D", *c.Difficulty, 6.402115)
	assertDue(t, "s2.2", c.Due, t1.Add(10*time.Minute))

	// Step 3: Good at t0+15m (same-day → graduate to Review)
	t2 := t0align.Add(15 * time.Minute)
	c, _ = s.ReviewCard(c, Good, t2)
	assertState(t, "s2.3", c.State, Review)
	assertStep(t, "s2.3", c.Step, nil)
	assertFloat(t, "s2.3 S", *c.Stability, 0.284206)
	assertFloat(t, "s2.3 D", *c.Difficulty, 6.390941)
	assertDue(t, "s2.3", c.Due, t2.Add(1*24*time.Hour))
}

// Scenario 3: NewCard → Good → Good → Again → Relearning Good → Review
func TestAlignScenario3_GoodGoodAgainRelearningGood(t *testing.T) {
	s := alignScheduler(t)
	card := NewCard(1)

	// Step 1: Good at t0
	c, _ := s.ReviewCard(card, Good, t0align)
	assertState(t, "s3.1", c.State, Learning)
	assertFloat(t, "s3.1 S", *c.Stability, 2.3065)
	assertFloat(t, "s3.1 D", *c.Difficulty, 2.118104)

	// Step 2: Good at t0+10m → Review
	t1 := t0align.Add(10 * time.Minute)
	c, _ = s.ReviewCard(c, Good, t1)
	assertState(t, "s3.2", c.State, Review)
	assertFloat(t, "s3.2 S", *c.Stability, 2.3065)
	assertFloat(t, "s3.2 D", *c.Difficulty, 2.111214)

	// Step 3: Again at t0+5d+10m → Relearning
	t2 := t0align.Add(5*24*time.Hour + 10*time.Minute)
	c, _ = s.ReviewCard(c, Again, t2)
	assertState(t, "s3.3", c.State, Relearning)
	assertStep(t, "s3.3", c.Step, ptrI(0))
	assertFloat(t, "s3.3 S", *c.Stability, 0.682735)
	assertFloat(t, "s3.3 D", *c.Difficulty, 7.392238)
	assertDue(t, "s3.3", c.Due, t2.Add(10*time.Minute))

	// Step 4: Good at t0+5d+20m → Review
	t3 := t0align.Add(5*24*time.Hour + 20*time.Minute)
	c, _ = s.ReviewCard(c, Good, t3)
	assertState(t, "s3.4", c.State, Review)
	assertStep(t, "s3.4", c.Step, nil)
	assertFloat(t, "s3.4 S", *c.Stability, 0.735606)
	assertFloat(t, "s3.4 D", *c.Difficulty, 7.380074)
	assertDue(t, "s3.4", c.Due, t3.Add(1*24*time.Hour))
}

// Scenario 4: NewCard → Easy (directly to Review)
func TestAlignScenario4_EasyDirectReview(t *testing.T) {
	s := alignScheduler(t)
	card := NewCard(1)

	c, _ := s.ReviewCard(card, Easy, t0align)
	assertState(t, "s4.1", c.State, Review)
	assertStep(t, "s4.1", c.Step, nil)
	assertFloat(t, "s4.1 S", *c.Stability, 8.2956)
	assertFloat(t, "s4.1 D", *c.Difficulty, 1.0)
	assertDue(t, "s4.1", c.Due, t0align.Add(8*24*time.Hour))
}

// Scenario 5: NewCard → Hard (stays Learning, step interpolation)
func TestAlignScenario5_HardFromNew(t *testing.T) {
	s := alignScheduler(t)
	card := NewCard(1)

	c, _ := s.ReviewCard(card, Hard, t0align)
	assertState(t, "s5.1", c.State, Learning)
	assertStep(t, "s5.1", c.Step, ptrI(0))
	assertFloat(t, "s5.1 S", *c.Stability, 1.2931)
	assertFloat(t, "s5.1 D", *c.Difficulty, 5.112171)
	// Hard at step=0, len=2 → (1m + 10m) / 2 = 5m30s
	assertDue(t, "s5.1", c.Due, t0align.Add(5*time.Minute+30*time.Second))
}
